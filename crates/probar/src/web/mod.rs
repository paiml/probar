//! Zero-JavaScript Web Asset Generation (Advanced Feature E)
//!
//! Programmatic HTML, CSS, and minimal JavaScript generation with full
//! validation and coverage tracking. Follows the Zero-JavaScript Policy:
//! - HTML/CSS/JS are generated programmatically, never written by hand
//! - JavaScript is limited to under 20 lines (WASM loader only)
//! - All generated assets are linted and validated
//! - Coverage tracking for generated web assets

mod css_builder;
mod html_builder;
mod js_builder;
mod validator;

pub use css_builder::{CssBuilder, CssRule, GeneratedCss};
pub use html_builder::{Element, GeneratedHtml, HtmlBuilder, HtmlDocument};
pub use js_builder::{GeneratedJs, JsBuilder, WasmConfig};
pub use validator::{
    AccessibilityIssue as WebAccessibilityIssue, CssLintResult, HtmlValidationResult,
    JsLintResult, SecurityIssue, Severity as WebSeverity, ValidationReport, WebValidator,
};

/// Complete web asset bundle generated by Probar
#[derive(Debug, Clone)]
pub struct WebBundle {
    /// Generated HTML document
    pub html: GeneratedHtml,
    /// Generated CSS stylesheet
    pub css: GeneratedCss,
    /// Generated JavaScript (minimal WASM loader)
    pub js: GeneratedJs,
    /// Validation report for all assets
    pub validation: ValidationReport,
}

impl WebBundle {
    /// Create a new web bundle from components
    #[must_use]
    pub fn new(html: GeneratedHtml, css: GeneratedCss, js: GeneratedJs) -> Self {
        let validation = WebValidator::validate_all(&html, &css, &js);
        Self {
            html,
            css,
            js,
            validation,
        }
    }

    /// Check if bundle passes all validation
    #[must_use]
    pub fn is_valid(&self) -> bool {
        self.validation.is_valid()
    }

    /// Get the complete HTML document with embedded CSS and JS
    #[must_use]
    pub fn to_single_file(&self) -> String {
        format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
{css}
    </style>
</head>
<body>
{body}
    <script>
{js}
    </script>
</body>
</html>"#,
            title = self.html.title,
            css = self.css.content,
            body = self.html.body_content,
            js = self.js.content,
        )
    }
}

/// Coverage tracking for generated web assets
#[derive(Debug, Clone, Default)]
pub struct WebAssetCoverage {
    /// HTML element coverage
    pub html_elements: std::collections::HashMap<String, WebElementCoverage>,
    /// CSS rule coverage
    pub css_rules: std::collections::HashMap<String, RuleCoverage>,
    /// JS function coverage
    pub js_functions: std::collections::HashMap<String, FunctionCoverage>,
}

/// Coverage data for an HTML element
#[derive(Debug, Clone, Default)]
pub struct WebElementCoverage {
    /// Element ID
    pub id: String,
    /// Number of interactions
    pub interaction_count: u64,
    /// Types of interactions
    pub interaction_types: Vec<String>,
}

/// Coverage data for a CSS rule
#[derive(Debug, Clone, Default)]
pub struct RuleCoverage {
    /// CSS selector
    pub selector: String,
    /// Number of times rule was applied
    pub application_count: u64,
}

/// Coverage data for a JS function
#[derive(Debug, Clone, Default)]
pub struct FunctionCoverage {
    /// Function name
    pub name: String,
    /// Number of executions
    pub execution_count: u64,
}

impl WebAssetCoverage {
    /// Create new coverage tracker
    #[must_use]
    pub fn new() -> Self {
        Self::default()
    }

    /// Record element interaction
    pub fn element_used(&mut self, id: &str, interaction_type: &str) {
        let entry = self.html_elements.entry(id.to_string()).or_default();
        entry.id = id.to_string();
        entry.interaction_count += 1;
        if !entry.interaction_types.contains(&interaction_type.to_string()) {
            entry.interaction_types.push(interaction_type.to_string());
        }
    }

    /// Record CSS rule application
    pub fn rule_applied(&mut self, selector: &str) {
        let entry = self.css_rules.entry(selector.to_string()).or_default();
        entry.selector = selector.to_string();
        entry.application_count += 1;
    }

    /// Record JS function execution
    pub fn function_executed(&mut self, name: &str) {
        let entry = self.js_functions.entry(name.to_string()).or_default();
        entry.name = name.to_string();
        entry.execution_count += 1;
    }

    /// Calculate overall coverage percentage
    #[must_use]
    pub fn coverage_percent(&self) -> f64 {
        let html_covered = self
            .html_elements
            .values()
            .filter(|e| e.interaction_count > 0)
            .count();
        let css_covered = self
            .css_rules
            .values()
            .filter(|r| r.application_count > 0)
            .count();
        let js_covered = self
            .js_functions
            .values()
            .filter(|f| f.execution_count > 0)
            .count();

        let total = self.html_elements.len() + self.css_rules.len() + self.js_functions.len();
        let covered = html_covered + css_covered + js_covered;

        if total == 0 {
            100.0
        } else {
            (covered as f64 / total as f64) * 100.0
        }
    }

    /// Generate coverage report
    #[must_use]
    pub fn report(&self) -> WebAssetCoverageReport {
        WebAssetCoverageReport {
            html_coverage: self.calculate_html_coverage(),
            css_coverage: self.calculate_css_coverage(),
            js_coverage: self.calculate_js_coverage(),
            overall_coverage: self.coverage_percent(),
        }
    }

    fn calculate_html_coverage(&self) -> f64 {
        let total = self.html_elements.len();
        let covered = self
            .html_elements
            .values()
            .filter(|e| e.interaction_count > 0)
            .count();
        if total == 0 {
            100.0
        } else {
            (covered as f64 / total as f64) * 100.0
        }
    }

    fn calculate_css_coverage(&self) -> f64 {
        let total = self.css_rules.len();
        let covered = self
            .css_rules
            .values()
            .filter(|r| r.application_count > 0)
            .count();
        if total == 0 {
            100.0
        } else {
            (covered as f64 / total as f64) * 100.0
        }
    }

    fn calculate_js_coverage(&self) -> f64 {
        let total = self.js_functions.len();
        let covered = self
            .js_functions
            .values()
            .filter(|f| f.execution_count > 0)
            .count();
        if total == 0 {
            100.0
        } else {
            (covered as f64 / total as f64) * 100.0
        }
    }
}

/// Coverage report for web assets
#[derive(Debug, Clone)]
pub struct WebAssetCoverageReport {
    /// HTML element coverage percentage
    pub html_coverage: f64,
    /// CSS rule coverage percentage
    pub css_coverage: f64,
    /// JS function coverage percentage
    pub js_coverage: f64,
    /// Overall coverage percentage
    pub overall_coverage: f64,
}

#[cfg(test)]
#[allow(clippy::unwrap_used, clippy::expect_used)]
mod tests {
    use super::*;

    // =========================================================================
    // H₀-WEB-01: WebBundle creation and validation
    // =========================================================================

    #[test]
    fn h0_web_01_bundle_creation() {
        let html = HtmlBuilder::new()
            .title("Test App")
            .canvas("app", 800, 600)
            .build()
            .unwrap();

        let css = CssBuilder::new().responsive_canvas("app").build().unwrap();

        let js = JsBuilder::new("app.wasm", "app").build().unwrap();

        let bundle = WebBundle::new(html, css, js);
        assert!(bundle.is_valid());
    }

    #[test]
    fn h0_web_02_bundle_single_file_output() {
        let html = HtmlBuilder::new()
            .title("Test")
            .canvas("canvas", 100, 100)
            .build()
            .unwrap();

        let css = CssBuilder::new().build().unwrap();
        let js = JsBuilder::new("test.wasm", "canvas").build().unwrap();

        let bundle = WebBundle::new(html, css, js);
        let output = bundle.to_single_file();

        assert!(output.contains("<!DOCTYPE html>"));
        assert!(output.contains("<title>Test</title>"));
        assert!(output.contains("<style>"));
        assert!(output.contains("<script>"));
    }

    // =========================================================================
    // H₀-WEB-03: WebAssetCoverage tracking
    // =========================================================================

    #[test]
    fn h0_web_03_coverage_tracking() {
        let mut coverage = WebAssetCoverage::new();

        // Register elements
        coverage.html_elements.insert(
            "button".to_string(),
            WebElementCoverage {
                id: "button".to_string(),
                interaction_count: 0,
                interaction_types: vec![],
            },
        );

        coverage.css_rules.insert(
            "#button".to_string(),
            RuleCoverage {
                selector: "#button".to_string(),
                application_count: 0,
            },
        );

        // Initially 0% coverage
        assert_eq!(coverage.coverage_percent(), 0.0);

        // Use element
        coverage.element_used("button", "click");
        assert!(coverage.coverage_percent() > 0.0);

        // Apply CSS rule
        coverage.rule_applied("#button");
        assert_eq!(coverage.coverage_percent(), 100.0);
    }

    #[test]
    fn h0_web_04_coverage_report() {
        let mut coverage = WebAssetCoverage::new();

        coverage.html_elements.insert(
            "a".to_string(),
            WebElementCoverage {
                id: "a".to_string(),
                interaction_count: 1,
                interaction_types: vec!["click".to_string()],
            },
        );

        coverage.html_elements.insert(
            "b".to_string(),
            WebElementCoverage {
                id: "b".to_string(),
                interaction_count: 0,
                interaction_types: vec![],
            },
        );

        let report = coverage.report();
        assert_eq!(report.html_coverage, 50.0);
        assert_eq!(report.css_coverage, 100.0); // No CSS rules = 100%
        assert_eq!(report.js_coverage, 100.0); // No JS functions = 100%
    }

    #[test]
    fn h0_web_05_empty_coverage_is_100_percent() {
        let coverage = WebAssetCoverage::new();
        assert_eq!(coverage.coverage_percent(), 100.0);
    }
}
